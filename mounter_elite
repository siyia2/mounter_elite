#!/bin/bash

# Read propmt color and style
YELLOW=$(tput setaf 3)
RESET=$(tput sgr0)

BOLD=$(tput bold)

# Main script
iso_count=1
iso_paths=()

# Function to mount an ISO file in parallel
mount_iso_parallel() {
	local iso_files=("$@")

	for iso_file in "${iso_files[@]}"; do
		while [ -e "/mnt/iso_$iso_count" ]; do
			((iso_count++)) # Increment iso_count until an available number is found
		done

		local mount_point
		for ((i = 1; ; i++)); do
			mount_point="/mnt/iso_$i"
			if [ ! -e "$mount_point" ]; then
				break
			fi
		done

		if [ -e "$mount_point" ]; then
			echo "An ISO is already mounted at '$mount_point'."
		else
			sudo mkdir -p "$mount_point"

			(
			# Subshell for parallel execution
			sudo mount -o loop "$iso_file" "$mount_point"
			echo "ISO file '$iso_file' mounted at '$mount_point'."
			mounted_isos+=("$mount_point") # Add the mount point to the list
			) &                             # Run the subshell in the background
		fi

	done

	# Wait for all background jobs to complete
	wait

	echo -e "\e[1;32mAll ISO files have been mounted.\e[0m"
	mounted_isos+=("$mount_point")
}

# Function to unmount a specific ISO or multiple ISOs in parallel
unmount_iso_parallel_parallel() {
	local found_mounted=false
	local iso_folders=()

	# List the mounted ISO folders in the "/mnt" directory with a limited search depth
	mapfile -t iso_folders < <(find /mnt -maxdepth 1 -type d -name "iso_*")

	if [ ${#iso_folders[@]} -gt 0 ]; then
		found_mounted=true
	fi

	if [ "$found_mounted" = false ]; then
		echo -e "\e[1;31mNo mounted ISOs found.\e[0m"
		return
	fi

	# List the mounted ISOs
	echo "Mounted ISOs:"
	for ((i = 0; i < ${#iso_folders[@]}; i++)); do
		echo "$((i + 1)): ${iso_folders[i]}"
	done

	while true; do
		# Ask for user input
		read -r -e -p "${YELLOW}${BOLD}Enter the number(s) of the ISO(s) to unmount (1 or 1-3), or '}' to return:${RESET} " unmount_selection
		if [ "$unmount_selection" = '}' ]; then
			return
		elif [[ "$unmount_selection" =~ ^[0-9]+(-[0-9]+)?$ ]]; then
			IFS='-' read -r -a range <<<"$unmount_selection"
			start="${range[0]}"
		end="${range[1]:-$start}"

		if [ "$start" -ge 1 ] && [ "$end" -le ${#iso_folders[@]} ] && [ "$start" -le "$end" ]; then
			for ((i = start - 1; i < end; i++)); do
				local selected_folder="${iso_folders[i]}"
				(
				sudo umount -l "$selected_folder"
				echo "ISO $((i + 1)) unmounted."
				# Remove the ISO folder after unmounting
				sudo rmdir -p "$selected_folder" 2> /dev/null
				echo "Folder $((i + 1)) removed."
				) & # Run the unmounting process in the background
			done

				# Wait for all background processes to finish
				wait
				return
			else
				echo -e "\e[1;31mInvalid selection. Please provide a valid ISO number or range.\e[0m"
		fi
	else
		echo -e "\e[1;31mInvalid input. Please enter a valid ISO number or range, or '}' to return.\e[0m"
		fi
	done
}
# Function to unmount all ISOs in parallel
unmount_all_isos_parallel() {
	mapfile -t iso_folders < <(find /mnt -maxdepth 1 -type d -name "iso_*")

	local should_print_message=true

	for mount_point in "${iso_folders[@]}"; do
		(
		sudo umount -l "$mount_point"
		sudo rmdir "$mount_point"
		) &
		should_print_message=false
	done

	wait

	if [ "$should_print_message" = true ]; then
		echo -e "\e[1;31mNo ISO folders found in /mnt\e[0m"
	else
		echo -e "\e[1;32mAll mounted ISOs have been unmounted in parallel.\e[0m"
	fi
}

# Function to list either iso or bin and img files with numbers
list_iso_files_multithreaded() {

	while true; do
		# Prompt the user for a directory path
		read -r -e -p "${BOLD}${YELLOW}Enter a valid directory path or '}' to return${RESET}: " dir_path
		if [[ "$dir_path" == '}' ]]; then
			echo "Exiting List Mode..."
			return
		elif [ ! -d "$dir_path" ]; then
			echo -e "\e[1;31mInvalid Directory: $dir_path\e[0m"

		else
			break # Exit the loop if the directory is valid
		fi
	done

	case $choice in
		1)
			iso_files=()
			case $choice_small in
				1)	
					# Use find with null character delimiter to handle spaces in file paths
					IFS=$'\n' read -d '' -r -a iso_files < <(find "$dir_path" -maxdepth 5 -type f -iname "*.iso" -print0 | xargs -0 -r -P "$(nproc)" realpath)
					;;

				*)
					echo -e "\e[1;31mInvalid choice.\e[0m"
					return
					;;
			esac

			if [ -z "${iso_files[*]}" ]; then
				echo -e "\e[1;33mNo .iso files were found under the specified path."
			else
				echo "List of files in '$dir_path' and its subdirectories (up to 5 levels deep) with numbers:"
				echo " "
				for ((i = 0; i < ${#iso_files[@]}; i++)); do
					echo "$((i + 1)): ${iso_files[i]}"
				done
			fi
			;;
		*)
			echo -e "\e[1;31mInvalid choice.\e[0m"
			;;
	esac

}

select_and_mount_files_by_number() {
	local list=("$@")
	local selected=()
	local selected_numbers=()
	local input=""
	if [[ "$dir_path" == '}' ]]; then
		return
	else
		while true; do
			read -r -e -p "${YELLOW}${BOLD}Enter the number(s) of the file(s) to select&mount e.g. ( 1 } or 1 3 5 } or '}' to return):${RESET} " input

		# Split input by spaces
		read -r -a num_array <<<"$input"

		for num in "${num_array[@]}"; do
			if [ "$num" = "}" ]; then
				break 2 # Exit both inner and outer loops
			elif [[ "$num" =~ ^[0-9]+$ && "$num" -ge 1 && "$num" -le ${#list[@]} ]]; then
				if ! [[ " ${selected_numbers[*]} " =~ $num ]]; then
					selected_numbers+=("$num")
					selected+=("${list[num - 1]}")
				else
					echo "Number $num has already been selected."
				fi
			else
				echo -e "\e[1;31mInvalid number: $num\e[0m"
			fi
		done
	done

	# Mount the selected files
	for file in "${selected[@]}"; do
		if [ -e "$file" ]; then
			mount_iso_parallel "$file"
		else
			echo "The specified file '$file' does not exist, no ISO mounted..."
		fi
	done
	fi
}

select_and_convert_files_to_iso_multithreaded() {
	local dir_path="$1"
	local selected=()  # Initialize an empty array for selected files

    # Check if the directory exists and is accessible
    if [ ! -d "$dir_path" ] || [ ! -r "$dir_path" ]; then
	    echo -e "\e[1;31mError: The specified directory does not exist or is not accessible.\e[0m"
	    return
    fi

    # List .img and .bin files that meet specific criteria
    img_bin_files=()
    # Use find with null character delimiter to handle spaces in file paths
    IFS=$'\n' read -d '' -r -a img_bin_files < <(find "$dir_path" -maxdepth 5 -type f \( -iname "*.img" -o -iname "*.bin" \) -size +50000c -print0 | xargs -0 -r -P "$(nproc)" realpath)

    if [ -z "${img_bin_files[*]}" ]; then
	    echo -e "\e[1;31mNo .img or .bin files over 50MB were found.\e[0m"
	    return
    fi

    while true; do
	    # Display the list of files
	    echo "List of .img and .bin files over 50MB in '$dir_path' and its subdirectories (up to 5 levels deep):"
	    for ((i = 0; i < ${#img_bin_files[@]}; i++)); do
		    echo "$((i + 1)): ${img_bin_files[i]}"
	    done

	    read -r -p "${YELLOW}${BOLD}Enter your selections for ISO conversions (1 or 1 2 3 or '}' to return):${RESET}${BOLD} " input

	    IFS=" " read -ra user_selections <<< "$input"

	    for selection in "${user_selections[@]}"; do
		    if [[ "$selection" =~ ^[0-9]+$ ]] && [ "$selection" -le "${#img_bin_files[@]}" ]; then
			    selected+=("${img_bin_files[$selection - 1]}")
			    echo -e "\e[1;32mSelected: ${img_bin_files[$selection - 1]}\e[0m"
		    elif [ "$selection" == "}" ]; then
			    if [ ${#selected[@]} -eq 0 ]; then
				    echo -e "\e[1;31mNo files were selected for conversion.\e[0m"
				    return
			    fi
			    # Call convert_to_iso to convert the selected files to ISO format
			    convert_to_iso "${selected[@]}"
			    return
		    else
			    echo -e "\e[1;31mInvalid selection. Enter the numbers of the files to select & convert, e.g. (1 } or 1 2 }, or '}' to return.\e[0m"
		    fi
	    done
    done
}



# Function to convert image files to ISO
convert_to_iso() {
	local input_paths=("$@")
	local results=()  # Create an array to store the results

	for input_path in "${input_paths[@]}"; do
		if [ "$input_path" == '}' ]; then
			return
		fi
		if [ -e "$input_path" ]; then
			if [[ "${input_path,,}" == *.iso ]]; then
				results+=("The file '$input_path' is already in ISO format.")
			else
				if command -v ccd2iso &>/dev/null; then
					local output_path="${input_path%.*}.iso"
					ccd2iso "$input_path" "$output_path"
					if [ -e "$output_path" ]; then
						results+=("Image file converted to ISO: $output_path")
					else
						results+=("Conversion of '$input_path' failed.")
					fi
				else
					results+=("ccd2iso is not installed. Please install it before using this option.")
				fi
			fi
		else
			results+=("The specified input file '$input_path' does not exist.")
		fi
	done

    # Display all results
    for result in "${results[@]}"; do
	    echo -e "${BOLD}$result"
    done
}

function manual_mode_imgs() {
	echo -e "\e[1;34mOperating On Manual Mode\e[0m"
	read -r -e -p "${YELLOW}${BOLD}Enter image file(s) path(s) to convert (separate by space), or press '}' to return:${RESET} " input_paths

	if [ "$input_paths" == "}" ]; then
		echo -e "\e[1;31mExiting Manual Mode...No IMGs for conversion were selected"
		return
	fi

    # Remove double quotes from the beginning and end of the string, if they exist
    input_paths="${input_paths%\"}"
    input_paths="${input_paths#\"}"

		# Split the input string into an array based on spaces
		IFS=" " read -a input_paths <<<"$input_paths"

		# Perform the conversion for Manual Mode
		convert_to_iso "${input_paths[@]}"
	}


	function manual_mode_isos() {
		echo -e "\e[1;34mOperating in Manual Mode\e[0m"
		valid_paths=()
		invalid_paths_str=""
		mounting_complete=false

		while true; do
			read -r -e -p "${YELLOW}${BOLD}Enter path(s) of ISO files (separate by space), or '}' to return:${RESET} " iso_paths
			iso_paths="${iso_paths%\"}"
			iso_paths="${iso_paths#\"}"

			if [[ "$iso_paths" == '}' ]]; then
				if $mounting_complete; then
					echo "Exiting Manual Mode..."
					break
				else
					echo -e "\e[1;31mExiting Manual Mode...No ISOs for mounting were selected\e[0m"
					break
					continue
				fi
			fi

			IFS=" " read -r -a selected_files <<<"$iso_paths"

			invalid_paths=()
			for iso_path in "${selected_files[@]}"; do
				if [ -e "$iso_path" ] && [ -f "$iso_path" ]; then
					valid_paths+=("$iso_path")
				else
					invalid_paths+=("$iso_path")
				fi
			done

			if [ ${#invalid_paths[@]} -gt 0 ]; then
				invalid_paths_str=$(IFS=" "; echo "${invalid_paths[*]}")
				echo "Invalid Path(s): $invalid_paths_str"
			else
				for iso_path in "${valid_paths[@]}"; do
					if [ -e "$iso_path" ]; then
						# Call your mount_iso_parallel function here
						mount_iso_parallel "$iso_path"
						mounting_complete=true
					fi
				done
				valid_paths=()  # Clear valid_paths for the next iteration
			fi
		done
	}
	# Function to pause and wait for a key press
	pause() {

		read -r -e -p "Press any key to continue..."
		echo " "
	}

# Array to store the list of mounted ISOs
mounted_isos=()
clear
while true; do

	clear

echo -e "\e[1;32m _____          ___ _____ _____   ___ __   __  ___  _____ _____   __   __  ___ __   __ _   _ _____ _____ ____         _    __   ___  
|  ___)   /\   (   (_   _|  ___) (   |  \ /  |/ _ \|  ___|  ___) |  \ /  |/ _ (_ \ / _| \ | (_   _|  ___|  _ \       / |  / /  / _ \ 
| |_     /  \   | |  | | | |_     | ||   v   | |_| | |   | |_    |   v   | | | |\ v / |  \| | | | | |_  | |_) )  _  _- | / /_ | | | |
|  _)   / /\ \  | |  | | |  _)    | || |\_/| |  _  | |   |  _)   | |\_/| | | | | | |  |     | | | |  _) |  __/  | |/ | || '_ \| | | |
| |___ / /  \ \ | |  | | | |___   | || |   | | | | | |   | |___  | |   | | |_| | | |  | |\  | | | | |___| |     | / /| || (_) | |_| |
|_____/_/    \_(___) |_| |_____) (___|_|   |_|_| |_|_|   |_____) |_|   |_|\___/  |_|  |_| \_| |_| |_____|_|     |__/ |_(_\___/ \___/ 
                                                                                                                                      \e[0m"

echo "Select an option:
1) List and Mount ISOs
2) Unmount ISOs
3) Clean and Unmount All ISOs
4) Convert BIN/IMG to ISO
5) Open /mnt directory
6) Exit"
read -r -e -p "${YELLOW}${BOLD}Enter the number of your choice:${RESET} " choice
			case $choice in
				1)
					while true; do
						read -r -e -p "${YELLOW}${BOLD}1) List Mode, 2) Manual Mode, or '}' to return:${RESET} " choice_small

						case "$choice_small" in
							1)
								echo -e "\e[1;34mOperating in List Mode\e[0m"
								# Call your list_iso_files_multithreaded function here
								list_iso_files_multithreaded "$dir_path"
								mapfile -t selected_files < <(select_and_mount_files_by_number "${iso_files[@]}")
								;;
							2)
								manual_mode_isos
								;;
							'}')
								echo "Exiting..."
								break
								;;
							*)
								echo -e "\e[1;31mInvalid Choice\e[0m"
								;;
						esac
					done
					;;
				2)
					# Call your unmount_iso_parallel_parallel function here
					unmount_iso_parallel_parallel
					pause
					;;
				3)
					# Call your unmount_all_isos_parallel function here
					unmount_all_isos_parallel
					pause
					;;
				4)
					while true; do
						read -r -e -p "${YELLOW}${BOLD}1) List Mode, 2) Manual Mode, or '}' to return:${RESET} " choice

						if [[ "$choice" == '}' ]]; then
							echo "Exiting..."
							break
						elif [[ "$choice" == 1 ]]; then
							echo -e "\e[1;34mOperating In List Mode\e[0m"

							while true; do
								read -r -e -p "${YELLOW}${BOLD}Enter directory path for BIN/IMG list generation, or '}' to return:${RESET} " dir_path

								if [[ "$dir_path" == '}' ]]; then
									echo "Exiting List Mode..."
									break
								elif [[ -d "$dir_path" ]]; then
									# Call your select_and_convert_files_to_iso_multithreaded function here
									select_and_convert_files_to_iso_multithreaded "$dir_path"

			# Optionally, provide an option to return to the main menu
			read -r -p "Press Enter to return to the main menu..."
		else
			echo -e "\e[1;31mError: Invalid Path: $dir_path\e[0m"
								fi
							done
						elif [[ "$choice" == 2 ]]; then
							manual_mode_imgs
						else
							echo -e "\e[1;31mError: Invalid choice: $choice\e[0m"
						fi
					done
					;;

				5)
					nohup xdg-open /mnt/ >/dev/null 2>&1 &
					;;
				6)
					echo "Exiting the program..."
					exit 0
					;;
				*)
					echo -e "\e[1;31mInvalid choice. Please enter 1, 2, 3, 4, 5 or 6.\e[0m"
					pause
					;;
			esac
		done
