#!/bin/bash

mounted_isos=()

# Read propmt color and style
YELLOW=$(tput setaf 3)
RESET=$(tput sgr0)

BOLD=$(tput bold)

# Main script
iso_count=1
iso_paths=()

# Function to mount an ISO file in parallel
mount_iso() {
    local iso_files=("$@")
    
    for iso_file in "${iso_files[@]}"; do
        while [ -e "/mnt/iso_$iso_count" ]; do
    ((iso_count++))  # Increment iso_count until an available number is found
done

local mount_point
for ((i = 1; ; i++)); do
    mount_point="/mnt/iso_$i"
    if [ ! -e "$mount_point" ]; then
        break
    fi
done

if [ -e "$mount_point" ]; then
    echo "An ISO is already mounted at '$mount_point'."
else
    sudo mkdir -p "$mount_point"
    
    (
        # Subshell for parallel execution
        sudo mount -o loop "$iso_file" "$mount_point"
        echo "ISO file '$iso_file' mounted at '$mount_point'."
        mounted_isos+=("$mount_point") # Add the mount point to the list
    ) &  # Run the subshell in the background
fi


    done
    
    # Wait for all background jobs to complete
    wait
    
    echo "All ISO files have been mounted."
    mounted_isos+=("$mount_point")
}

# Function to unmount a specific ISO or multiple ISOs in parallel
unmount_iso_parallel() {
    local unmount_selection="$1"

    if [[ "$unmount_selection" =~ ^[0-9]+(-[0-9]+)?$ ]]; then
        IFS='-' read -r -a range <<< "$unmount_selection"
        start="${range[0]}"
        end="${range[1]:-$start}"  # If no second number is provided, use the first one

        if [ "$start" -ge 1 ] && [ "$end" -le $iso_count ] && [ "$start" -le "$end" ]; then
            for num in $(seq "$start" "$end"); do
                local mount_point="/mnt/iso_$num"
                if [ -e "$mount_point" ]; then
                    (
                        sudo umount "$mount_point"
                        sudo rmdir "$mount_point"
                        # Remove the unmounted ISO from the list
                        mounted_isos=("${mounted_isos[@]/$mount_point/}")
                        echo "ISO $num unmounted."
                    ) &  # Run the unmounting process in the background
                else
                    echo "No ISO mounted at '$mount_point'."
                fi
            done
            iso_count=$((iso_count - end + start + 1))
        else
            echo "Invalid ISO range. No action performed."
        fi
    else
        local mount_point="/mnt/iso_$unmount_selection"
        if [ -e "$mount_point" ]; then
            (
                sudo umount "$mount_point"
                sudo rmdir "$mount_point"
                # Parse the ISO number from the mount point path
                local num
                num="${mount_point#/mnt/iso_}"
                echo "ISO $num unmounted."
                # Remove the unmounted ISO from the list
                mounted_isos=("${mounted_isos[@]/$mount_point/}")
                iso_count=$((iso_count - 1))
            ) &  # Run the unmounting process in the background
        else
            echo "No ISO mounted at '$mount_point'."
        fi
    fi
}

# Function to unmount all ISOs in parallel
unmount_all_isos_parallel() {
	for ((i = 1; i < iso_count; i++)); do
		local mount_point="/mnt/iso_$i"
		if [ -e "$mount_point" ]; then
			(
				sudo umount "$mount_point"
				sudo rmdir "$mount_point"
			) &  # Run the unmounting process in the background
		fi
	done

	# Wait for all background unmounting processes to complete
	wait

	echo "All mounted ISOs have been unmounted in parallel."
}

# Function to convert image files to ISO
convert_to_iso() {
	local input_paths=("$@")
	for input_path in "${input_paths[@]}"; do
		if [ -e "$input_path" ]; then
			if [[ "$input_path" == *.iso ]]; then
				echo -e "\e[1;33mThe file '$input_path' is already in ISO format.\e[0m"
			else
				if command -v ccd2iso &>/dev/null; then
					local output_path="${input_path%.*}.iso"
					ccd2iso "$input_path" "$output_path"
					if [ -e "$output_path" ]; then
						echo -e "\e[1;32mImage file converted to ISO: $output_path\e[0m"
					else
						echo -e "\e[1;31mConversion of '$input_path' failed.\e[0m"
					fi
				else
					echo -e "\e[1;33mccd2iso is not installed. Please install it before using this option.\e[0m"
				fi
			fi
		else
			echo -e "\e[1;31mThe specified input file '$input_path' does not exist.\e[0m"
		fi
	done
}

# Function to list either iso or bin and img files
list_iso_bin_img_files() {
	local dir_path="$1"

	if [ -d "$dir_path" ]; then

		# Use the choice_small parameter to determine which option was selected
		case $choice in
		1)
			iso_files=$(find "$dir_path" -maxdepth 5 -type f -iname "*.iso" -print0 | xargs -0 -r -P "$(nproc)" realpath | sed 's/ /\\ /g')
			if [ -z "$iso_files" ]; then
				echo -e "\e[1;33mNo .iso files were found under the specified path."
			else
				echo "List of .iso files in '$dir_path' and its subdirectories (up to 5 levels deep) with absolute paths:"
				echo -e "\e[1;32m"
				echo -e "$iso_files"
			fi
			echo ""
			;;
		4)
			bin_img_files=$(find "$dir_path" -maxdepth 5 -type f \( -iname "*.bin" -o -iname "*.img" \) -size +10M -print0 | xargs -0 -r -P "$(nproc)" realpath | sed 's/ /\\ /g')
			if [ -z "$bin_img_files" ]; then
				echo -e "\e[1;33mNo .bin or .img files (larger than 10MB) were found under the specified path."
			else
				echo "List of .bin and .img files (excluding files larger than 10MB) in '$dir_path' and its subdirectories (up to 5 levels deep) with absolute paths:"
				echo -e "\e[1;32m"
				echo "$bin_img_files"
			fi
			echo ""
			;;
		*)
			echo -e "\e[1;31mInvalid choice.\e[0m"
			;;
		esac
	fi
}


# Function to pause and wait for a key press
pause() {
	read -r -e -p "Press any key to continue...
"
	echo " "
}

# Array to store the list of mounted ISOs
mounted_isos=()
	clear
while true; do

	clear
	
	echo -e "\e[1;32m┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓"
	echo -e "                   ELITE IMAGE MOUNTER                        "
	echo -e "┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\e[0m"

	echo "1. Mount ISO(s) (separate paths with space)"
	echo "2. Unmount ISO(s) (e.g., '1' or '1-2')"
	echo "3. Unmount all ISOs"
	echo "4. Convert IMG(s) to ISO(s) (separate paths with space)"
	echo "5. Open /mnt/"
	echo "6. Exit"
	read -r -p "${YELLOW}Choose an option (1/2/3/4/5/6):${RESET}${BOLD} " choice

	case $choice in
	1)	
		read -r -e -p "${YELLOW}Press 1 for List Mode or 2 for Manual Mode:${RESET}${BOLD} " choice_small
		
		if [[ "$choice_small" = 1 ]]; then
		echo -e "\e[1;34mOperating On List Mode\e[0m"
		read -r -e -p "${YELLOW}Enter directory path for ISO list generation:${RESET}${BOLD} " dir_path
		list_iso_bin_img_files "$dir_path"
		read -r -e -p "${YELLOW}Enter path(s) from list above to mount (separate with spaces), or press enter to quit:${RESET}${BOLD} " iso_paths
		fi
		if [[ "$choice_small" = 2 ]]; then
		echo -e "\e[1;34mOperating On Manual Mode\e[0m"
		read -r -e -p "${YELLOW}Enter path(s) of ISO files (separate with spaces), or press enter to quit:${RESET}${BOLD} " iso_paths
		fi
		# Remove double quotes from the beginning and end of the string, if they exist
		iso_paths="${iso_paths%\"}"
		iso_paths="${iso_paths#\"}"

		# Split the input string into an array based on spaces
		IFS=" " read -a iso_paths <<<"$iso_paths"

		for iso_path in "${iso_paths[@]}"; do
			if [ -e "$iso_path" ]; then
				mount_iso "$iso_path"
			else
				echo -e "\e[1;31mThe specified ISO file '$iso_path' does not exist, no ISO mounted...\e[0m"
			fi
		done
		pause
		;;
	2)
        if [ $iso_count -eq 1 ]; then
            echo -e "\e[1;31mNo ISOs are mounted.\e[0m"
        else
            if [ "${#mounted_isos[@]}" -gt 0 ]; then
                echo "List of mounted ISOs:"
                for ((i = 0; i < "${#mounted_isos[@]}"; i++)); do
                    echo "ISO $((i + 1)): ${mounted_isos[i]}"
                done
            else
                echo -e "\e[1;31mNo ISOs are mounted.\e[0m"
            fi

            read -r -p "${YELLOW}Enter the number(s) of the ISO(s) to unmount (e.g., '1' or '1-2') or 'exit' to go back:${RESET}${BOLD} " unmount_selection
            if [ "$unmount_selection" == "exit" ]; then
                continue
            else
                unmount_iso_parallel "$unmount_selection"  # Call the parallelized function
            fi
        fi
        pause
        ;;
	3)
		if [ $iso_count -eq 1 ]; then
			echo -e "\e[1;33mNo ISOs are mounted, but cleaning mount dirs just in case...\e[0m"
			sudo umount /mnt/iso_*
			sudo rm -r /mnt/iso_*
		else
			unmount_all_isos_parallel
			iso_count=1
			mounted_isos=()
		fi
		pause
		;;
	4)	
		read -r -e -p "${YELLOW}Press 1 for List Mode or 2 for Manual Mode:${RESET}${BOLD} " choice_small
		
		if [[ "$choice_small" = 1 ]]; then
		echo -e "\e[1;34mOperating On List Mode\e[0m"
		read -r -e -p "${YELLOW}Enter directory path for BIN/IMG list generation:${RESET}${BOLD} " dir_path
		list_iso_bin_img_files "$dir_path" 
		read -r -e -p "${YELLOW}Enter from the list above path(s) for conversion (separate with spaces), or press enter to quit:${RESET}${BOLD} " input_paths 
		fi
		if [[ "$choice_small" = 2 ]]; then
		echo -e "\e[1;34mOperating On Manual Mode\e[0m"
		read -r -e -p "${YELLOW}Enter image file(s) path(s) you want to convert (separate with spaces), or press enter to quit:${RESET}${BOLD} " input_paths
		fi
		
		# Remove double quotes from the beginning and end of the string, if they exist
		input_paths="${input_paths%\"}"
		input_paths="${input_paths#\"}"

		# Split the input string into an array based on spaces
		IFS=" " read -a input_paths <<<"$input_paths"

		convert_to_iso "${input_paths[@]}"
		read -r -p "Press Enter to return to the main menu..."
		;;
	5)
		nohup xdg-open /mnt/ >/dev/null 2>&1 &
		read -r -p "Press Enter to return to the main menu..."
		;;
	6)
		echo "Exiting the program."
		exit 0
		;;
	*)
		echo -e "\e[1;31mInvalid choice. Please enter 1, 2, 3, 4, 5 or 6.\e[0m"
		pause
		;;
	esac
done
